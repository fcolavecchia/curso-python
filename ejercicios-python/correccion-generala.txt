		   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
		    CORRECCION EJERCICIO GENERALA

			      Cátedra 2022
		   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━





Castro, Facundo; Nota: 9
═══════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están bien documentadas

  • ☑ Uso de bibliotecas. Usa bien,  argparse y random bien usadas (np y plt también). 
      Usa widgets de matplotlib para la UI. 

  • ☑ Modularización. El programa está algo modularizado, convendría separar las funciones
  entre aquellas que manejan el estado del juego, y aquellas que muestran dicho estado.



Específicos [6/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☑ Gráficos e interfaz de usuario
  5. ☑ Juega la computadora
  6. ☑ Algoritmo de selección de juego de la computadora 


Otros Comentarios/correcciones/ideas
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • La GUI está muy bien. 

  • Sugiero definir el estado del juego (jugadores, puntajes, estado de los dados, etc.) 
    en algún tipo de estructura. Esto evitaría el uso de las variables globales que 
    no está recomendado. Un indicio de esto es tener muchas funciones que no reciben argumentos.

  • Muy bien el algoritmo de cálculo del juego de la computadora.

  • La variable `int_v' se usa sólamente cuando se calcula `int_v(np.random.uniform(1,7,5))',
    quizás sea mejor reemplazarla por una función que devuelva lo requerido y listo. 

  


Cuevas, Santiago; Nota:  9
═══════════════════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están algo documentadas

  • ☑ Uso de bibliotecas. Usa bien, argparse y random bien usadas. 
    Usa pygame para  la UI.

  • ☑ Modularización. El programa está en un solo archivo, aunque define algunas clases
  para estructurar datos. 



Específicos [6/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☑ Gráficos e interfaz de usuario
  5. ☑ Juega la computadora
  6. ☑ Algoritmo de selección de juego de la computadora 


Otros Comentarios/correcciones/ideas
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • Hay que ser prudente con el uso de los nombres de variables. Por ejemplo,
  la clase `but` debería llamarse `Button` o algo similar. El hecho que `but` 
  en inglés signifique *pero* complica la lectura del código. Idem con `Abut`
  (¿por qué no `ActionButton`?). Dejo una frase famosa de CS para pensar:
  > "There are 2 hard problems in computer science: cache invalidation, 
    *naming things*, and off-by-1 errors."

  • Hay mucho bloque de código repetido, por ejemplo en la función `carga_tabla()`.
    
  • Sugiero definir el estado del juego (jugadores, puntajes, estado de los dados, etc.) 
    en algún tipo de estructura. Esto evitaría el uso de las variables globales que 
    no está recomendado. Un indicio de esto es tener muchas funciones que no reciben argumentos.

  • Ojo con las barras de directorios, pueden cambiar entre Sistemas Operativos, con
   lo cual el código no corre. Usar por ejemplo `os.path.join()`.

  • Mucho número mágico en el código, esto es, literales de tipo entero por todas partes.

  • El algoritmo de juego de la computadora es bastante críptico, y no tiene comentarios.


Estrada, ; Nota:  10
═══════════════════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están  documentadas.

  • ☑ Uso de bibliotecas. Usa argparse, pandas, itertools; tkinter para la UI.

  • ☑ Modularización. El programa está muy bien modularizado.



Específicos [7/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☑ Gráficos e interfaz de usuario
  5. ☑ Juega la computadora
  6. ☑ Algoritmo de selección de juego de la computadora 


Otros Comentarios/correcciones/ideas
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • Pandas se usa en un solo lugar, pareciera como que es demasiado, quizás 
    reemplazandola por alguna funcionalidad base de Python alcanza, y uno se
    ahorra una biblioteca (que es importante a la hora de distribuir código, por
    ejemplo).
  
  • Habría que mostrar los 'juegos que puede reclamar' en orden.
  
  • La instrucción sobre qué dados tirar resulta confusa. 

  • Muy interesantes los bots de juego!


Rinaldi, ; Nota:  10
═══════════════════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están  documentadas con docstring.

  • ☑ Uso de bibliotecas. Usa argparse, PIL ; tkinter para la UI.

  • ☑ Modularización. El programa está en un solo archivo, pero usa 
  clases para estructurar datos y funciones. 


Específicos [7/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☑ Gráficos e interfaz de usuario
  5. ☑ Juega la computadora
  6. ☑ Algoritmo de selección de juego de la computadora 

  • El código está muy bien estructurado, convendría separarlo en módulos
    para que sea más facil de leer.

  • La estrategia usada por el bot no le permite buscar una escalera, por ejemplo, 
    que sólo salen servidas o se tachan.

  • Quizás no es necesario usar tantas ventanas modales en cada tirada, imprimir 
    algo de info extra en algún lugar de la main windows a veces es mejor.     
  
  • Se acostumbra a poner los botones abajo en las interfaces, o a lo sumo a la derecha.

  • Muy interesante el modo -noGUI, para analizar el bot. 


Sandor, ; Nota:  9
═══════════════════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están  documentadas, en su mayoría con docstring.

  • ☑ Uso de bibliotecas. Usa argparse.

  • ☑ Modularización. El programa está en un solo archivo, pero usa 
  clases para estructurar datos y funciones. 


Específicos [6/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☐ Gráficos e interfaz de usuario
  5. ☑ Juega la computadora
  6. ☑ Algoritmo de selección de juego de la computadora 


  • El argparse tira un error si no se ponen jugadores.  

  • No hay interfaz gráfica de usuario, pero el juego via la consola funciona muy bien. 
    El único detalle al que le falta un poco de claridad es cómo seleccionar los dados.  

  • En la impresión de la tabla se nota código repetido que podría simplificarse usando
    funciones muy sencillas (linea 436 y subsiguientes). Si uno no quisiera usar funciones, 
    se puede indentar el código para que quede más claro. 

  • En Python 3.10 en adelante se puede usar `match ... switch` en lugar de 
    `if...elif`. 



Sheffield, Facundo ; Nota:  8
═══════════════════════════════════

Puntos a evaluar
────────────────

Generales [3/3]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  • ☑ Documentación. Las funciones están  documentadas, en su mayoría con docstring.

  • ☑ Uso de bibliotecas. Usa pygame.

  • ☑ Modularización. El programa está en un solo archivo, usa variables globales.


Específicos [5/7]:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

  1. ☑ Simulación del juego para un jugador
  2. ☑ Algoritmos de puntaje y selección de tiradas
  3. ☑ Simulación para varios jugadores
  4. ☑ Gráficos e interfaz de usuario
  5. ☐ Juega la computadora
  6. ☐ Algoritmo de selección de juego de la computadora 


  • No está implementado el juego por parte de la computadora. 

  • Al menos en macOS no se ven bordes de botones o cajas de texto para completar (por ejemplo
    al agregar jugadores en el modo multijugador.). Puede ser alguna dependencia del SO. 

  • El juego está implementado en un loop con distintas condiciones (estados) que van cambiando.
    El cambio entre condiciones podría implementarse en funciones, para poder separar el estado
    del juego de la visualización. 

  • Mucho número mágico en el código, esto es, literales de tipo entero por todas partes.
  
  • Muy interesante el detalle del sonido de los dados.   

